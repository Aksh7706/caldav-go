package values

import (
	"fmt"
	"github.com/taviti/caldav-go/icalendar"
	"time"
)

const DateTimeFormatString = "20060102T150405"

// a representation of a date and time for iCalendar
type DateTime struct {
	t time.Time
}

type dateTimes []*DateTime

// The exception dates, if specified, are used in computing the recurrence set. The recurrence set is the complete set
// of recurrence instances for a calendar component. The recurrence set is generated by considering the initial
// "DTSTART" property along with the "RRULE", "RDATE", "EXDATE" and "EXRULE" properties contained within the iCalendar
// object. The "DTSTART" property defines the first instance in the recurrence set. Multiple instances of the "RRULE"
// and "EXRULE" properties can also be specified to define more sophisticated recurrence sets. The final recurrence set
// is generated by gathering all of the start date-times generated by any of the specified "RRULE" and "RDATE"
// properties, and then excluding any start date and times which fall within the union of start date and times
// generated by any specified "EXRULE" and "EXDATE" properties. This implies that start date and times within exclusion
// related properties (i.e., "EXDATE" and "EXRULE") take precedence over those specified by inclusion properties
// (i.e., "RDATE" and "RRULE"). Where duplicate instances are generated by the "RRULE" and "RDATE" properties, only
// one recurrence is considered. Duplicate instances are ignored.
//
// The "EXDATE" property can be used to exclude the value specified in "DTSTART". However, in such cases the original
// "DTSTART" date MUST still be maintained by the calendaring and scheduling system because the original "DTSTART"
// value has inherent usage dependencies by other properties such as the "RECURRENCE-ID".
type ExceptionDateTimes dateTimes

// The recurrence dates, if specified, are used in computing the recurrence set. The recurrence set is the complete set
// of recurrence instances for a calendar component. The recurrence set is generated by considering the initial
// "DTSTART" property along with the "RRULE", "RDATE", "EXDATE" and "EXRULE" properties contained within the iCalendar
// object. The "DTSTART" property defines the first instance in the recurrence set. Multiple instances of the "RRULE"
// and "EXRULE" properties can also be specified to define more sophisticated recurrence sets. The final recurrence set
// is generated by gathering all of the start date-times generated by any of the specified "RRULE" and "RDATE"
// properties, and then excluding any start date and times which fall within the union of start date and times
// generated by any specified "EXRULE" and "EXDATE" properties. This implies that start date and times within exclusion
// related properties (i.e., "EXDATE" and "EXRULE") take precedence over those specified by inclusion properties
// (i.e., "RDATE" and "RRULE"). Where duplicate instances are generated by the "RRULE" and "RDATE" properties, only
// one recurrence is considered. Duplicate instances are ignored.
type RecurrenceDateTimes dateTimes

// creates a new icalendar datetime representation
func NewDateTime(t time.Time) *DateTime {
	return &DateTime{t: t}
}

// encodes the datetime value for the iCalendar specification
func (d *DateTime) EncodeICalValue() string {
	val := d.t.Format(DateTimeFormatString)
	loc := d.t.Location()
	if loc == time.UTC {
		val = fmt.Sprintf("%sZ", val)
	}
	return val
}

// encodes the datetime params for the iCalendar specification
func (d *DateTime) EncodeICalParams() (params map[string]string) {
	loc := d.t.Location()
	if loc != time.UTC {
		params = map[string]string{"TZID": loc.String()}
	}
	return
}

// validates the datetime value against the iCalendar specification
func (d *DateTime) ValidateICalValue() error {

	loc := d.t.Location()

	if loc == time.Local {
		msg := "DateTime location may not Local, please use UTC or explicit Location"
		return icalendar.NewError(d.ValidateICalValue, msg, d, nil)
	}

	if loc.String() == "" {
		msg := "DateTime location must have a valid name"
		return icalendar.NewError(d.ValidateICalValue, msg, d, nil)
	}

	return nil
}

// encodes the datetime value for the iCalendar specification
func (d *DateTime) String() string {
	return d.EncodeICalValue()
}

// encodes a list of datetime values for the iCalendar specification
func (ds dateTimes) EncodeICalValue() string {
	var csv CSV
	for _, d := range ds {
		csv = append(csv, d.EncodeICalValue())
	}
	return csv.EncodeICalValue()
}

// encodes exception date times property name for icalendar
func (e ExceptionDateTimes) EncodeICalName() string {
	return "EXDATE"
}

// encodes recurrence date times property name for icalendar
func (r RecurrenceDateTimes) EncodeICalName() string {
	return "RDATE"
}

// encodes exception date times property value for icalendar
func (e ExceptionDateTimes) EncodeICalValue() string {
	return dateTimes(e).EncodeICalValue()
}

// encodes recurrence date times property value for icalendar
func (r RecurrenceDateTimes) EncodeICalValue() string {
	return dateTimes(r).EncodeICalValue()
}

// encodes exception date times property params for icalendar
func (e ExceptionDateTimes) EncodeICalParams() (params map[string]string) {
	if len(e) > 0 {
		params = e[0].EncodeICalParams()
	}
	return
}

// encodes recurrence date times property params for icalendar
func (r RecurrenceDateTimes) EncodeICalParams() (params map[string]string) {
	if len(r) > 0 {
		params = r[0].EncodeICalParams()
	}
	return
}

//TODO: validate explicit timezone and add params
