package values

import (
	"fmt"
	"strings"
)

// The recurrence rule, if specified, is used in computing the recurrence set. The recurrence set is the complete set
// of recurrence instances for a calendar component. The recurrence set is generated by considering the initial
// "DTSTART" property along with the "RRULE", "RDATE", "EXDATE" and "EXRULE" properties contained within the iCalendar
// object. The "DTSTART" property defines the first instance in the recurrence set. Multiple instances of the "RRULE"
// and "EXRULE" properties can also be specified to define more sophisticated recurrence sets. The final recurrence
// set is generated by gathering all of the start date/times generated by any of the specified "RRULE" and "RDATE"
// properties, and excluding any start date/times which fall within the union of start date/times generated by any
// specified "EXRULE" and "EXDATE" properties. This implies that start date/times within exclusion related properties
// (i.e., "EXDATE" and "EXRULE") take precedence over those specified by inclusion properties
// (i.e., "RDATE" and "RRULE"). Where duplicate instances are generated by the "RRULE" and "RDATE" properties, only
// one recurrence is considered. Duplicate instances are ignored.

// The "DTSTART" and "DTEND" property pair or "DTSTART" and "DURATION" property pair, specified within the iCalendar
// object defines the first instance of the recurrence. When used with a recurrence rule, the "DTSTART" and "DTEND"
// properties MUST be specified in local time and the appropriate set of "VTIMEZONE" calendar components MUST be
// included. For detail on the usage of the "VTIMEZONE" calendar component, see the "VTIMEZONE" calendar component
// definition.

// Any duration associated with the iCalendar object applies to all members of the generated recurrence set. Any
// modified duration for specific recurrences MUST be explicitly specified using the "RDATE" property.
type RecurrenceRule struct {
	Frequency     RecurrenceFrequency
	Until         *DateTime
	Count         int
	Interval      int
	BySecond      []int
	ByMinute      []int
	ByHour        []int
	ByDay         []RecurrenceWeekday
	ByMonthDay    []int
	ByYearDay     []int
	ByWeekNumber  []int
	ByMonth       []int
	BySetPosition []int
	WeekStart     RecurrenceWeekday
}

// the frequency an event recurs
type RecurrenceFrequency string

const (
	SecondRecurrenceFrequency RecurrenceFrequency = "SECONDLY"
	MinuteRecurrenceFrequency                     = "MINUTELY"
	HourRecurrenceFrequency                       = "HOURLY"
	DayRecurrenceFrequency                        = "DAILY"
	WeekRecurrenceFrequency                       = "WEEKLY"
	MonthRecurrenceFrequency                      = "MONTHLY"
	YearRecurrenceFrequency                       = "YEARLY"
)

// the frequency an event recurs
type RecurrenceWeekday string

const (
	MondayRecurrenceWeekday    RecurrenceWeekday = "MO"
	TuesdayRecurrenceWeekday                     = "TU"
	WednesdayRecurrenceWeekday                   = "WE"
	ThursdayRecurrenceWeekday                    = "TH"
	FridayRecurrenceWeekday                      = "FR"
	SaturdayRecurrenceWeekday                    = "SA"
	SundayRecurrenceWeekday                      = "SU"
)

// creates a new recurrence rule object for iCalendar
func NewRecurrenceRule(frequency RecurrenceFrequency) *RecurrenceRule {
	return &RecurrenceRule{Frequency: frequency}
}

// encodes the RRULE value for the iCalendar specification
func (r *RecurrenceRule) EncodeICalValue() string {
	out := []string{fmt.Sprintf("FREQ=%s", r.Frequency)}
	if r.Until != nil {
		out = append(out, fmt.Sprintf("UNTIL=%s", r.Until))
	}
	if r.Count > 0 {
		out = append(out, fmt.Sprintf("COUNT=%d", r.Count))
	}
	if r.Interval > 0 {
		out = append(out, fmt.Sprintf("INTERVAL=%d", r.Count))
	}
	if len(r.BySecond) > 0 {
		out = append(out, fmt.Sprintf("BYSECOND=%s", intsToCSV(r.BySecond)))
	}
	if len(r.ByMinute) > 0 {
		out = append(out, fmt.Sprintf("BYMINUTE=%s", intsToCSV(r.ByMinute)))
	}
	if len(r.ByHour) > 0 {
		out = append(out, fmt.Sprintf("BYHOUR=%s", intsToCSV(r.ByHour)))
	}
	if len(r.ByDay) > 0 {
		out = append(out, fmt.Sprintf("BYDAY=%s", daysToCSV(r.ByDay)))
	}
	if len(r.ByMonthDay) > 0 {
		out = append(out, fmt.Sprintf("BYMONTHDAY=%s", intsToCSV(r.ByMonthDay)))
	}
	if len(r.ByYearDay) > 0 {
		out = append(out, fmt.Sprintf("BYYEARDAY=%s", intsToCSV(r.ByYearDay)))
	}
	if len(r.ByWeekNumber) > 0 {
		out = append(out, fmt.Sprintf("BYWEEKNO=%s", intsToCSV(r.ByWeekNumber)))
	}
	if len(r.ByMonth) > 0 {
		out = append(out, fmt.Sprintf("BYMONTH=%s", intsToCSV(r.ByMonth)))
	}
	if len(r.BySetPosition) > 0 {
		out = append(out, fmt.Sprintf("BYSETPOS=%s", intsToCSV(r.BySetPosition)))
	}
	if r.WeekStart != "" {
		out = append(out, fmt.Sprintf("WKST=%s", r.WeekStart))
	}
	return strings.Join(out, ";")
}

func intsToCSV(ints []int) string {
	var csv CSV
	for _, i := range ints {
		csv = append(csv, fmt.Sprintf("%d", i))
	}
	return csv.EncodeICalValue()
}

func daysToCSV(days []RecurrenceWeekday) string {
	var csv CSV
	for _, day := range days {
		csv = append(csv, string(day))
	}
	return csv.EncodeICalValue()
}
